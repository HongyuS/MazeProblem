//#-hidden-code
//
//  main.swift
//
//  Copyright Â© 2021 Hongyu Shi. All rights reserved.
//
//#-end-hidden-code
/*:
 # BIM3009 Assignment II - Mazing Problem #
 
 A maze with a specified size M x N can be generated by using a **two-dimensional array** with the size (M+2) x (N+2), in which 0s are open paths, 1s are barriers, point (1, 1) is the Entrance, and point (M, N) is the Exit. Then, a **stack** is applied to assist the search of a path starting from the Entrance to the Exit.
 
 **Data Input**:
 A maze with size (M+2) x (N+2) in which point (1, 1) is the Entrance and point (M, N) is the Exit.
 
 **Data Output**: (Console)
 Print out the traversal route if there is a path starting from the Entrance point (1, 1) to Exit point (M, N); otherwise, the output is "There is no path to Exit in the maze!".
 
 **Graphical Display**: (GUI)
 
 - *Dark gray* blocks are walls.
 
 - *Green* blocks shows the solution.
 
 - *Orange* blocks shows all positions visited.
 
 Perss "Solve Maze" button to solve the maze. If there exists a solution, the label in the botton-right corner will change to "Solved!"; otherwise, it would remain "No Path Found".
 You can also press "Reset Maze" to generate a new random maze (may not have a solution).
 */
/// A static demo Maze for testing
//#-editable-code
let demoMaze: String = """
++++++++++++++++++++++
+   +   ++ ++     ++++
+ +   +       +++ + ++
+ + +  ++  ++++   + ++
+++ ++++++    +++ +  +
+          ++  ++    +
+++++ ++++++   +++++ +
+     +   +++++++  + +
+ +++++++        +   +
+      +   ++    + +++
+++++ ++     +++++++ +
+ ++ ++   ++++  ++ +++
++++ +++++++  + ++++++
++   +++    ++++++ + +
+++ ++ +++++    ++   +
+   +++++    ++++   ++
+ ++     ++++  +++ +++
+ ++ ++++++++++++ + ++
+ ++ ++          ++ ++
+ ++   +++ +++   +++++
+++ ++++++   ++++    +
++++++++++++++++++++++
"""
//#-end-editable-code
//#-hidden-code
import SwiftUI
import PlaygroundSupport
//#-end-hidden-code

// MARK: - Function to make Maze
/*:
 This function makes a random maze of given size.

 The random maze may not have a solution.

 - parameter `rows`: Number of rows in the maze.
 - parameter `columns`: Number of columns in the maze.
 - returns: A random maze of type `Maze`.

 **Notes:**
 1. For convenience, the maze must be surrounded by walls, so the actuall number of rows and columns in the matrix are `(rows + 2)` and `(columns + 2)`.
 2. The top left position (`[1, 1]`) is the entrance and the bottom right position (`[rows, columns]`) is the goal.

 **Example**
 ```
 let randomMaze = makeMaze(of: 10, by: 10)
 ```
 */
func makeMaze(of rows: Int, by columns: Int) -> Maze {
    // Inplementation is hidden here, but if you
    // are interested, you may check it on GitHub.
    //#-hidden-code
    // Initiate an empty martix
    var maze = Maze(rows: rows + 2, columns: columns + 2,
                    defaultValue: 0)
    // Generate random entries of the matrix
    for i in 0 ... rows + 1 {
        for j in 0 ... columns + 1 {
            if i == 0 || j == 0 || i == rows + 1 || j == columns + 1 {
                maze[i, j] = 1
            } else if (i != 1 || j != 1) && (i != rows || j != columns) {
                maze[i, j] = Int.random(in: 0 ... 1)
            }
        }
    }
    return maze
    //#-end-hidden-code
}

/*:
 This function makes a maze from a given string.

 Here is an example of input maze:
 ```
 ++++++++
 + ++ +++
 ++   + +
 + ++ +++
 ++ ++  +
 ++++++++
 ```
 - parameter `mazeString`: The `String` representation of a maze.
 - returns: The `Matrix` representation of the given maze.

 **Notes:**
 1. The input string must have lines with equal length, and it must consist of "`+`" representing walls and "` `" representing pathways.
 2. The input maze must be surrounded by walls. The top left position is the entrance and the bottom right position is the goal, thus they must be linked with empty pathways.
 3. Handle return type because it is optional.

 **Example**
 ```
 if let maze = makeMaze(from: demoMaze) {
     /*< Do something here >*/
 }
 ```
 */
func makeMaze(from mazeString: String) -> Maze? {
    // Inplementation is hidden here, but if you
    // are interested, you may check it on GitHub.
    //#-hidden-code
    // Get number of rows and columns from the input string
    let rows: [Substring] = mazeString.split(separator: "\n")
    let rowCount: Int = rows.count
    let columnCount: Int = rows[1].count
    // Construct the grid array from the input string
    var mazeGrid = [Int]()
    for character in mazeString {
        if character == "+" {
            mazeGrid.append(1)
        } else if character == " " {
            mazeGrid.append(0)
        }
    }
    // Check if the structure is correct, and return the maze
    guard mazeGrid.count == rowCount * columnCount else { return nil }
    return Maze(rows: rowCount, columns: columnCount, grid: mazeGrid)
    //#-end-hidden-code
}

/*:
 ## Implementation of the **Maze** ##
 
 The `Maze` type is a value type conforming to `protocol Matrix` defined in `Matrix.swift`.
 
 The **Maze** object implementation is divided into three parts. First, I defined some stored properties such as the array to store the map, the stack to store visited positions, and a flag to indicate whether the maze is solved. The second part contains some subtypes such as `Direction` and `Coordinate`.
 
 Finally, with all the utilities defined, I implemented the main algorithm to solve the maze in the third part. The detailed implementations are inspired by the PPT from lecture.
 */
// MARK: - Definition of Maze
// This is the Model
struct Maze: Matrix {
    typealias Element = Int
    let rows: Int
    let columns: Int
    var grid: [Int]
    
    /// Matrix to store visited positions
    private(set) var mark: PathMark
    /// Matrix to store path
    private(set) var path: PathMark?
    /// Stack to store the path visited
    private(set) var stack = Stack<Coordinate>()
    /// The current coordinate to the starting position
    private(set) var coord: Coordinate?
    /// Number of steps to solve the maze
    private(set) var steps: Int = 0
    /// A marker indicating whether the maze is solved
    private(set) var mazeIsSolved = false
    
    // MARK: Initializers
    /// Initialize a grid filled with default value
    public init(rows: Int, columns: Int, defaultValue: Element) {
        self.columns = columns
        self.rows = rows
        grid = Array(repeating: defaultValue, count: rows * columns)
        mark = PathMark(rows: rows, columns: columns,
                        defaultValue: .new)
    }
    /// Initialize from an existing grid
    public init(rows: Int, columns: Int, grid: [Element]) {
        self.columns = columns
        self.rows = rows
        self.grid = grid
        mark = PathMark(rows: rows, columns: columns,
                        defaultValue: .new)
    }
}

// MARK: - Subtypes and Methods of Maze
extension Maze {
    
    // MARK: Define subtypes used by Maze
    /// Coordinate of a position in the Maze
    struct Coordinate: Equatable {
        let row: Int
        let col: Int
        
        mutating func move(to dir: Direction) {
            self = self + dir.delta()
        }
        
        // Define Operator Methods
        static func + (left: Coordinate, right: Coordinate) -> Coordinate {
            return Coordinate(row: left.row + right.row,
                              col: left.col + right.col)
        }
        static func - (left: Coordinate, right: Coordinate) -> Coordinate {
            return Coordinate(row: left.row - right.row,
                              col: left.col - right.col)
        }
        // Compound Assignment Operators
        static func += (left: inout Coordinate, right: Coordinate) {
            left = left + right
        }
        static func -= (left: inout Coordinate, right: Coordinate) {
            left = left - right
        }
        // Equivalence Operator
        static func == (left: Coordinate, right: Coordinate) -> Bool {
            return (left.row == right.row) && (left.col == right.col)
        }
    }
    
    /// Directions which the player may move in the Maze
    enum Direction: String, CaseIterable {
        case north, northEast, east, southEast
        case south, southWest, west, northWest
        /// Get coordinate change after the movement
        func delta() -> Coordinate {
            switch self {
            case .north: return Coordinate(row: -1, col: 0)
            case .northEast: return Coordinate(row: -1, col: 1)
            case .east: return Coordinate(row: 0, col: 1)
            case .southEast: return Coordinate(row: 1, col: 1)
            case .south: return Coordinate(row: 1, col: 0)
            case .southWest: return Coordinate(row: 1, col: -1)
            case .west: return Coordinate(row: 0, col: -1)
            case .northWest: return Coordinate(row: -1, col: -1)
            }
        }
        /// Get the opposite direction
        func opposite() -> Direction {
            switch self {
            case .north: return .south
            case .northEast: return .southWest
            case .east: return .west
            case .southEast: return .northWest
            case .south: return .north
            case .southWest: return .northEast
            case .west: return .east
            case .northWest: return .southEast
            }
        }
    }
    
    /// Status of a position on the path
    enum PathStatus {
        case new
        case visited
    }
    
    /// Matrix to record visited positions on the path
    struct PathMark: Matrix {
        typealias Element = PathStatus
        let rows: Int
        let columns: Int
        var grid: [Element]
        public init(rows: Int, columns: Int, defaultValue: Element) {
            self.columns = columns
            self.rows = rows
            grid = Array(repeating: defaultValue, count: rows * columns)
        }
    }
    
    // MARK: Define coordinates of start & goal
    /// Coordinate of the starting position
    var start: Coordinate { Coordinate(row: 1, col: 1) }
    /// Coordinate of the goal of the Maze
    var goal: Coordinate { Coordinate(row: rows - 2,
                                      col: columns - 2) }
    
    // MARK: Functions to solve the Maze
    //#-editable-code
    /// Method to check whether the movement is valid
    /// - parameter dir: Direction of the movement
    /// - parameter coord: Starting coordinate
    /// - parameter mark: Reference to the marker matrix
    private func isMoveValid(_ dir: Direction,
                             _ coord: Coordinate,
                             _ mark: PathMark) -> Bool {
        let next = coord + dir.delta()
        guard mark[next.row, next.col] == .new else {
            return false
        }
        switch self[next.row, next.col] {
        case 0: return true
        default: return false
        }
    }
    
    /// Method to mark visited positions along the path
    /// - parameter coord: The coordinate visited
    /// - parameter mark: Reference to the marker matrix
    private func markVisited(at coord: Coordinate,
                             _ mark: inout PathMark) {
        mark[coord.row, coord.col] = .visited
    }
    
    /// Main function to solve the Maze
    public mutating func findPath() {
        self.coord = start
        self.markVisited(at: coord!, &mark)
        repeat {
            // Check whether the Maze is solved
            if coord! == goal {
                mazeIsSolved = true
                stack.add(coord!)
                break
            } else { // Solve the Maze here
                var moved = false
                for dir in Direction.allCases {
                    if isMoveValid(dir, coord!, mark) {
                        stack.add(coord!)
                        coord!.move(to: dir)
                        markVisited(at: coord!, &mark)
                        steps += 1
                        moved = true
                        break
                    }
                }
                if !moved {
                    if let coord = stack.pop() {
                        self.coord = coord
                        steps += 1
                    } else {
                        print("There is no path to Exit in the maze!")
                    }
                }
            }
        } while !stack.isEmpty
        // Print the path to console if the maze is solved
        if mazeIsSolved {
            self.path = PathMark(rows: rows, columns: columns,
                                 defaultValue: .new)
            print("Path:")
            for coord in stack.rawData {
                markVisited(at: coord, &path!)
                print("(\(coord.row), \(coord.col))")
            }
        }
    }
    //#-end-editable-code
}


/*:
 Here defines the **View Model**.
 
 In the MVVM Design Pattern, the **view model**
 is defined to be the object to handle communications
 between the **model** (i.e. the "main logic")
 and the **view** (i.e. the GUI).
 
 Detailed implementations are hidden due
 to irrelevance to **BIM3009 Assignment 2**.
 */
// MARK: - ViewModel
class MazeViewModel: ObservableObject {
    // Hidden implementations:
    // Properties and methods are defined here
    //#-hidden-code
    @Published private var model: Maze
    
    private static func createRandomMaze() -> Maze {
        let dim = Int.random(in: 12 ... 20)
        return makeMaze(of: dim, by: dim)
    }
    
    private static func createDemoMaze() -> Maze {
        if let maze = makeMaze(from: demoMaze) {
            return maze
        } else {
            return createRandomMaze()
        }
    }
    
    init(_ mazeType: MazeType = .random) {
        switch mazeType {
        case .demo:
            model = MazeViewModel.createDemoMaze()
        case .random:
            model = MazeViewModel.createRandomMaze()
        }
    }
    
    // MARK: Access to the model
    // because it's a private var
    var rows: Int { model.rows }
    var columns: Int { model.columns }
    var grid: [Int] { model.grid }
    var mark: Maze.PathMark { model.mark }
    var path: Maze.PathMark? { model.path }
    var stack: Stack<Maze.Coordinate> { model.stack }
    var coord: Maze.Coordinate { model.coord ?? model.start }
    var steps: Int { model.steps }
    var mazeIsSolved: Bool { model.mazeIsSolved }
    
    // MARK: Intents
    
    func solveMaze() {
        model.findPath()
    }
    
    func resetMaze() {
        model = MazeViewModel.createRandomMaze()
    }
}

extension MazeViewModel {
    enum MazeType {
        case demo
        case random
    }
    
    //#-end-hidden-code
}

/*:
 Here defines the **View**.
 
 In the MVVM Design Pattern, the **view** is defined
 to be the object to handle user interactions, i.e.
 the graphical user interface.
 
 Detailed implementations of the GUI are hidden
 due to irrelevance to **BIM3009 Assignment 2**.
 */
// MARK: - View
struct MazeProblemView: View {
    // Hidden implementations
    //#-hidden-code
    @StateObject var viewModel = MazeViewModel(.demo)
    
    var body: some View {
        VStack {
            HStack {
                topButton("Solve Maze") {
                    viewModel.solveMaze()
                }
                Spacer()
                topButton("Reset Maze") {
                    viewModel.resetMaze()
                }
            }
            
            ZStack(alignment: .center) {
                GeometryReader { geometry in
                    Group {
                        mazeLayer(size: geometry.size, type: .visited)
                        if viewModel.mazeIsSolved {
                            mazeLayer(size: geometry.size, type: .path)
                        }
                        mazeLayer(size: geometry.size, type: .wall)
                    }
                    .frame(width: min(geometry.size.width, geometry.size.height),
                            height: min(geometry.size.width, geometry.size.height),
                            alignment: .center)
                }
            }
            .padding(36)
            .clipShape(Rectangle())
            .padding()
            
            HStack {
                Text("Total steps: \(viewModel.steps)")
                    .padding(12)
                    .background(Color(.secondarySystemBackground))
                    .clipShape(RoundedRectangle(cornerRadius: 8, style: .continuous))
                
                Spacer()
                
                if viewModel.mazeIsSolved {
                    Text("Solved!")
                        .foregroundColor(.white)
                        .padding(12)
                        .background(Color.green)
                        .clipShape(RoundedRectangle(cornerRadius: 8, style: .continuous))
                } else {
                    Text("No Path Found")
                        .foregroundColor(.white)
                        .padding(12)
                        .background(Color.orange)
                        .clipShape(RoundedRectangle(cornerRadius: 8, style: .continuous))
                }
            }
            .font(.headline)
            .shadow(color: Color.black.opacity(0.2), radius: 8, x: 0, y: 4)
        }
        .padding(16)
    }
}

// MARK: ViewBuilders
extension MazeProblemView {
    @ViewBuilder private func topButton(_ label: String, action: @escaping () -> ()) -> some View {
        Button {
            withAnimation(.easeInOut(duration: 0.75)) {
                action()
            }
        } label: {
            Text(label)
                .foregroundColor(.white)
        }
        .padding(12)
        .background(Color.accentColor)
        .clipShape(RoundedRectangle(cornerRadius: 8, style: .continuous))
        .shadow(color: Color.black.opacity(0.4), radius: 8, x: 0, y: 8)
    }
    
    @ViewBuilder private func mazeLayer(size: CGSize, type: LayerType) -> some View {
        let (color, opacity) = type.color()
        let blockSize: CGFloat = min(size.height, size.width) / CGFloat(max(viewModel.mark.columns, viewModel.mark.rows))
        
        var markers = [Int]()
        switch type {
        case .visited:
            for marker in viewModel.mark.grid {
                switch marker {
                case .new:
                    markers.append(0)
                case .visited:
                    markers.append(1)
                }
            }
        case .path:
            for marker in viewModel.path!.grid {
                switch marker {
                case .new:
                    markers.append(0)
                case .visited:
                    markers.append(1)
                }
            }
        case .wall:
            markers = viewModel.grid
        }
        
        var columns: [GridItem] = Array(repeating: .init(.fixed(blockSize), spacing: 0), count: viewModel.rows)
        return LazyVGrid(columns: columns, spacing: 0) {
            ForEach((0 ..< markers.count), id: \.self) {
                color.opacity(markers[$0] == 0 ? 0 : opacity).frame(width: blockSize, height: blockSize, alignment: .center)
            }
        }.animation(.easeInOut(duration: 0.01))
    }
    
}

extension MazeProblemView {
    enum LayerType {
        case visited
        case path
        case wall
        
        func color() -> (Color, Double) {
            switch self {
            case .visited:
                return (Color.orange, 0.5)
            case .path:
                return (Color.green, 0.8)
            case .wall:
                return (Color(.darkGray), 1)
            }
        }
    }
    //#-end-hidden-code
}
//#-hidden-code
/// Create a view to display the Mazing Problem
PlaygroundPage.current.setLiveView(MazeProblemView())
//#-end-hidden-code
