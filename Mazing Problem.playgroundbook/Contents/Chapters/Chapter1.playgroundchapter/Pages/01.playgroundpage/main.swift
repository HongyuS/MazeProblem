//#-hidden-code
//
//  main.swift
//
//  Copyright Â© 2021 Hongyu Shi. All rights reserved.
//
//#-end-hidden-code
/*:
 **BIM3009 Assignment II - Mazing Problem**
 
 A maze with a specified size M x N can be generated by using a **two-dimensional array** with the size (M+2) x (N+2), in which 0s are open paths, 1s are barriers, point (1, 1) is the Entrance, and point (M, N) is the Exit. Then, if available, a **stack** can be applied to assist the search of a path starting from the Entrance to the Exit.
 
 **Data Input**:
 A maze with size (M+2) x (N+2) in which point (1, 1) is the Entrance and point (M, N) is the Exit.
 
 **Data Output**:
 Print out the traversal route if there is a path starting from the Entrance point (1, 1) to Exit point (M, N); otherwise, the output is "There is no path to Exit in the maze!".
 */
/// A static demo Maze for testing
//#-editable-code
let demoMaze: String = """
++++++++++++++++++++++
+   +   ++ ++     ++++
+ +   +       +++ + ++
+ + +  ++  ++++   + ++
+++ ++++++    +++ +  +
+          ++  ++    +
+++++ ++++++   +++++ +
+     +   +++++++  + +
+ +++++++        +   +
+      +   ++    + +++
+++++ ++     +++++++ +
+ ++ ++   ++++  ++ +++
++++ +++++++  + ++++++
++   +++    ++++++ + +
+++ ++ +++++    ++   +
+   +++++    ++++   ++
+ ++     ++++  +++ +++
+ ++ ++++++++++++ + ++
+ ++ ++          ++ ++
+ ++   +++ +++   +++++
+++ ++++++   ++++    +
++++++++++++++++++++++
"""
//#-end-editable-code
//#-hidden-code
import SwiftUI
import PlaygroundSupport
//#-end-hidden-code

// MARK: - Definition of Maze
// This is the Model
struct Maze: Matrix {
    typealias Element = Int
    let rows: Int
    let columns: Int
    
    // Maze represented using an array
    private(set) var grid: [Int]
    // Initiate the marker matrix
    private(set) var mark = PathMark(rows: rows, columns: columns,
                                     defaultValue: .new)
    // Initiate an empty stack to store the path visited
    private(set) var stack = Stack<(Coordinate, Direction)>()
    // Initiate the current coordinate to the starting position
    private(set) var coord = start
    // Number of steps to solve the maze
    private(set) var steps: Int = 0
    // A marker indicating whether the maze is solved
    private(set) var mazeIsSolved = false
    
    // MARK: Initializers
    /// Initialize a grid filled with default value
    public init(rows: Int, columns: Int, defaultValue: Element) {
        self.columns = columns
        self.rows = rows
        grid = Array(repeating: defaultValue, count: rows * columns)
    }
    /// Initialize from an existing grid
    public init(rows: Int, columns: Int, grid: [Element]) {
        self.columns = columns
        self.rows = rows
        self.grid = grid
    }
}

// MARK: - Subtypes and Methods of Maze
extension Maze {
    
    // MARK: Define subtypes used by Maze
    /// Coordinate of a position in the Maze
    struct Coordinate: Equatable {
        let row: Int
        let col: Int
        
        mutating func move(to dir: Direction) {
            self = self + dir.delta()
        }
        
        // Define Operator Methods
        static func + (left: Coordinate, right: Coordinate) -> Coordinate {
            return Coordinate(row: left.row + right.row,
                              col: left.col + right.col)
        }
        static func - (left: Coordinate, right: Coordinate) -> Coordinate {
            return Coordinate(row: left.row - right.row,
                              col: left.col - right.col)
        }
        // Compound Assignment Operators
        static func += (left: inout Coordinate, right: Coordinate) {
            left = left + right
        }
        static func -= (left: inout Coordinate, right: Coordinate) {
            left = left - right
        }
        // Equivalence Operator
        static func == (left: Coordinate, right: Coordinate) -> Bool {
            return (left.row == right.row) && (left.col == right.col)
        }
    }
    
    /// Directions which the player may move in the Maze
    enum Direction: String, CaseIterable {
        case north, northEast, east, southEast
        case south, southWest, west, northWest
        /// Get coordinate change after the movement
        func delta() -> Coordinate {
            switch self {
            case .north: return Coordinate(row: -1, col: 0)
            case .northEast: return Coordinate(row: -1, col: 1)
            case .east: return Coordinate(row: 0, col: 1)
            case .southEast: return Coordinate(row: 1, col: 1)
            case .south: return Coordinate(row: 1, col: 0)
            case .southWest: return Coordinate(row: 1, col: -1)
            case .west: return Coordinate(row: 0, col: -1)
            case .northWest: return Coordinate(row: -1, col: -1)
            }
        }
        /// Get the opposite direction
        func opposite() -> Direction {
            switch self {
            case .north: return .south
            case .northEast: return .southWest
            case .east: return .west
            case .southEast: return .northWest
            case .south: return .north
            case .southWest: return .northEast
            case .west: return .east
            case .northWest: return .southEast
            }
        }
    }
    
    /// Status of a position on the path
    enum PathStatus {
        case new
        case visited
    }
    
    /// Matrix to record visited positions on the path
    struct PathMark: Matrix {
        typealias Element = PathStatus
        let rows: Int
        let columns: Int
        var grid: [Element]
        public init(rows: Int, columns: Int, defaultValue: Element) {
            self.columns = columns
            self.rows = rows
            grid = Array(repeating: defaultValue, count: rows * columns)
        }
    }
    
    // MARK: Define coordinates of start & goal
    /// Coordinate of the starting position
    var start: Coordinate { Coordinate(row: 1, col: 1) }
    /// Coordinate of the goal of the Maze
    var goal: Coordinate { Coordinate(row: rows - 2,
                                      col: columns - 2) }
    
    // MARK: Functions to solve the Maze
    //#-editable-code
    /// Method to check whether the movement is valid
    /// - parameter dir: Direction of the movement
    /// - parameter coord: Starting coordinate
    /// - parameter mark: Reference to the marker matrix
    private func isMoveValid(_ dir: Direction,
                             _ coord: Coordinate,
                             _ mark: PathMark) -> Bool {
        let next = coord + dir.delta()
        guard mark[next.row, next.col] == .new else {
            return false
        }
        switch self[next.row, next.col] {
        case 0: return true
        default: return false
        }
    }
    
    /// Method to mark visited positions along the path
    /// - parameter coord: The coordinate visited
    /// - parameter mark: Reference to the marker matrix
    private func markVisited(at coord: Coordinate,
                             _ mark: inout PathMark) {
        mark[coord.row, coord.col] = .visited
    }
    
    /// Main function to solve the Maze
    public func findPath() {
        self.markVisited(at: start, &mark)
        repeat {
            // Check whether the Maze is solved
            if coord == goal {
                // print("Success!")
                mazeIsSolved = true
                break
            } else { // Solve the Maze here
                var moved = false
                for dir in Direction.allCases {
                    if isMoveValid(dir, coord, mark) {
                        stack.add((coord, dir))
                        coord.move(to: dir)
                        markVisited(at: coord, &mark)
                        steps += 1
                        // print("Coordinate (\(coord.row), \(coord.col)) is visited.")
                        moved = true
                        break
                    }
                }
                if !moved {
                    if let (coord, dir) = stack.pop() {
                        self.coord = coord
                    } else {
                        print("There is no path to Exit in the maze!")
                    }
                }
            }
        } while !stack.isEmpty
        // Print the path to console if the maze is solved
        if mazeIsSolved {
            print("Path:")
            for (coord, _) in stack.array {
                print("(\(coord.row), \(coord.col))")
            }
        }
    }
    
    //#-end-editable-code
}

/*:
 Here defines the **View Model**.
 
 In the MVVM Design Pattern, the **view model** is defined to be the object to handle communications between the **model** (i.e. the "main logic") and the **view** (i.e. the GUI).
 */
// MARK: - ViewModel
class MazeViewModel: ObservableObject {
    // Properties and methods are defined here
    //#-hidden-code
    @Published private var model: Maze
    
    private static func createRandomMaze() -> Maze {
        let dim = Int.random(in: 12 ... 20)
        return makeMaze(of: dim, by: dim)
    }
    
    private static func createDemoMaze() -> Maze {
        if let maze = makeMaze(from: demoMaze) {
            return maze
        } else {
            return createRandomMaze(of: 10, by: 10)
        }
    }
    
    init(_ mazeType: MazeType = .random) {
        switch mazeType {
        case .demo:
            model = createDemoMaze()
        case .random:
            model = createRandomMaze()
        }
    }
}

extension MazeViewModel {
    enum MazeType {
        case demo
        case random
    }
    
    //#-end-hidden-code
}

/*:
 Here defines the **View**.
 
 In the MVVM Design Pattern, the **view** is defined to be the object to handle the graphical user interface.
 */
struct MazeProblemView: View {
    @ObservedObject var viewModel: MazeViewModel
    
    var body: some View {
        Text("Maze")
    }
}

/// Create a view to display the Mazing Problem
//#-editable-code
let mazeProblemView = MazeProblemView(viewModel: MazeViewModel(.demo))
//#-end-editable-code
PlaygroundPage.current.liveView = mazeProblemView
//#-hidden-code
//#-end-hidden-code
